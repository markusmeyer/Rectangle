{"name":"Rectangle","tagline":"Helper classes and extension methods for handling rectangles comfortably","body":"Rectangle\r\n=========\r\n\r\nThese are some helper classes and extension methods for handling rectangles comfortably.\r\n\r\n### RectangleF\r\n\r\nRectangleF provides only two methods to specify a rectangle: \r\n\r\nBy constructor: \r\n\r\n\tnew RectangleF(10, 20, 30, 40)\r\n\r\nwhich takes top and left coordinates and width and height.\r\n\r\nBy static method: \r\n\r\n\tRectangleF.FromLTRB(10, 20, 30, 40)\r\n\r\nwhich takes left, top, right and bottom coordinates.\r\n\r\nBut often you want to specify the horizontal dimension differently from the vertical one, or specify the center and width / height, or the width and right coordinate, for example.\r\nTo avoid the cumbersome task of calculating the required parameters from the given ones each time, I created the Rect helper class.\r\n\r\n### Rect\r\n\r\nWith the Rect class you can specify a rectangle in a very flexible way:\r\n\r\nFor each dimension, two out of four possible specifications are made. For the horizontal dimension, this can be left, center, right and width. For the vertical dimension it can be top, center, bottom and height.\r\n\r\nIn the following example, we specify bottom coordinate, height, horizontal center coordinate and the width:\r\n\r\n\tRect.CreateWith.Bottom(40).Height(10).CenterX(20).Width(30).ToRectangleF()\r\n\r\n### Too much, too little?\r\n\r\nIf you there is just one or none specification per dimension, the range for a dimension is not defined. If you specify more than two things, they could contradict each other. In both cases, you will get an exception when you try to convert to RectangleF, but whether the right count of specifications has been provided can easily be seen from the source code.\r\n\r\nFollowing example will fail to execute, because the horizontal dimension is overspecified (left and right coordinate and width is given) and the vertical dimension is underspecified (only top coordinate is given):\r\n\r\n\tRect.CreateWith.Left(10).Right(20).Width(30).Top(40).ToRectangleF()\r\n\r\nSpecifying the same thing twice is no problem, however:\r\n\r\n\tRect.CreateWith.Left(10).Right(20).Top(30).Bottom(40).Left(20).ToRectangleF()\r\n\r\n### More flexible ways\r\n\r\nAs an alternative to providing direct coordinates or lengths, you can exctract them from other rectangles, points or sizes.\r\n\r\n\tRectangleF rect1 = new RectangleF(10, 20, 30, 40);\r\n\tPointF point = new PointF(50, 60);\r\n\tSizeF size = new SizeF(70,80);\r\n\r\n\tRectangleF rect2 = \r\n\t\tRect.CreateWith\r\n\t\t.TopLeft(point)\r\n\t\t.RightOf(rect1)\r\n\t\t.RelativeHeightOf(rect1, 2)\r\n\t\t.ToRectangleF();\r\n\r\n\tRectangleF rect3 = \r\n\t\tRect.CreateWith\r\n\t\t.Size(size)\r\n\t\t.AtRightOf(rect1)\r\n\t\t.AtBottomOf(rect1)\r\n\t\t.ToRectangleF();\r\n\r\n### More features\r\n\r\nIf you want to query again what you just set, you can do that as follows:\r\n\r\n\tRect rect = Rect.CreateWith.Left(20);\r\n\tfloat left = rect.GetLeft().Value;\r\n\r\nIf you want to use the same partial specifications to create two different rectangles, you can do this as follows:\r\n\r\n\tRect rect = Rect.CreateWith.Left(10).Right(20).Top(30);\r\n\tRectangleF rect1 = rect.Bottom(40).ToRectangleF();\r\n\tRectangleF rect2 = rect.Bottom(50).ToRectangleF();\r\n\r\n### Pointer semantics, but immutable\r\n\r\nRectangleF is a struct and thus has value semantics. Rect is a class and has pointer semantics. In order to be able to use a partial specification for different rectangles, the class is immutable and creates another instance for each modification operation.\r\n\r\nBecause of the immutability, you can do the following:\r\n\r\n\tRect rect = Rect.CreateWith.Left(10).Right(20).Top(30).Bottom(40);\r\n\tRectangleF rect2 = rect.Left(50).ToRectangleF();\r\n\tRectangleF rect3 = rect.Right(60).ToRectangleF();\r\n\r\nrect3.Left then will be the original 10 as expected, not 50.\r\n\r\n### Modify rectangles\r\n\r\nIf you want to modify a rectangle, let's say\r\n\r\n\tvar rect = new RectangleF(10, 20, 30, 40);\r\n\r\nyou could create a new Rect, copy the things which should remain the same, and change the others:\r\n\r\n\tRect.CreateWith.TopOf(rect).RightOf(rect).HeightOf(rect).Width(100).ToRectangleF()\r\n\r\nBut this is a bit lenghty and cumbersome. With the use of another helper class you can write\r\n\r\n\trect.With().SameTop().SameRight().SameHeight().Width(100).ToRectangleF()\r\n\r\nThe With extension method on RectangleF saves the original rectangle and you can transfer the desired \r\nspecifications just by calling the Same... methods. \r\n\r\nFollowing example relocates the top left corner of the rectangle:\r\n\r\n\trect.With().SameSize().Top(20).Left(30).ToRectangleF();\r\n\r\n### Even shorter\r\n\r\n\trect.With().SameTop().SameRight().SameHeight().Width(100).ToRectangleF()\r\n\r\nis still a bit lengthy, and can be written shorter as\r\n\r\n\trect.With().SameRight().Width(100).ToRectangleF()\r\n\r\nSo, as an exception to the above rule that for every dimension exactly two specifications have to be provided, \r\nyou can provide *zero* specifcations for a dimension, i.e. omitting the dimension as a whole.\r\nIt will be transferred to the new RectangleF as it was in the original RectangleF.\r\n\r\nNote that in the above example it would not be enough to only change the width:\r\n\r\n\trect.With().Width(100).ToRectangleF()\r\n\t\r\nIt's not specified which part of the horizontal range should remain the same: the left, the middle or the right.\r\nHence, in this case an exception is thrown stating that the dimension is underspecified.\r\n\r\nSome more examples with just one dimension changed:\r\n\r\n\trect.With().SameWidth().Left(30).ToRectangleF()\r\n\trect.With().Right(10).Width(20).ToRectangleF()\r\n\r\n### Relative sizes\r\n\r\nFor convenience, you can multiply the sizes of the original rectangle:\r\n\r\n\trect.With().SameCenter().RelativeHeight(.5f).RelativeWidth(.5f).ToRectangleF()\r\n\trect.With().SameCenter().RelativeSize(.5f).ToRectangleF()\r\n\r\n### Moving and enlarging\r\n\r\nOr you can move any side of the rectangle or enlarge / shrink its width and height.\r\n\r\nThis code moves the lop left corner while the bottom right corner remains fixed:\r\n\r\n\trect.With().SameRight().SameBottom().LeftMovedBy(10).TopMovedBy(20).ToRectangleF();\r\n\r\nAll 3 alternatives fix the center while enlarging the rectangle:\r\n\r\n\trect.With().SameCenter().WidthEnlargedBy(20).HeightEnlargedBy(30).ToRectangleF();\r\n\trect.With().SameCenter().EnlargedBy(new SizeF(20, 30)).ToRectangleF();\r\n\trect.With().SameCenter().EnlargedBy(20, 30).ToRectangleF();\r\n\r\nThis moves the rectangle:\r\n\r\n\trect.With().SameSize().LeftMovedBy(20).TopMovedBy(30).ToRectangleF();\r\n\r\nShorter:\r\n\r\n\trect.With().LeftTopMovedBy(20, 30).ToRectangleF();\r\n\r\nBecause writing the above line just to move a rectange is still too much code (and choosing a corner for adding the offset is\r\nredundant here), I have added extension methods for RectangleF directly, which are just for the task of moving it:\r\n\r\n\tvar r1 = rect.MovedBy(20, 30);\r\n\tvar r2 = rect.MovedRightBy(20);\r\n\tvar r3 = rect.MovedDownBy(30);\r\n\t\r\nOf course, you can also use RectangleF.Offset(PointF), but this method modifies the original RectangleF and doesn't return \r\nthe new one, so you can't use it in a functional style. \r\nI named the methods moved, not move, to indicate that they don't change the original Rect / RectangleF.\r\n\r\n### Corners and Centers\r\n\r\nSome more extension methods to RectangleF return the corners of the rectangle:\r\n\r\n\trect.TopLeft()\r\n\trect.BottomRight()\r\n\r\nThey also can be used with the Rect methods:\r\n\r\n\tRect.CreateWith.TopLeft(rect.BottomRight()).Size(10, 20).ToRectangleF();\r\n\r\nFinally, there are two extension methods to return the center coordinates of a rectangle:\r\n\r\n\trect.CenterX()\r\n\trect.CenterY()\r\n\t\r\n### Reference: Rect\r\n\r\n#### Get basic properties\r\n\r\n\tfloat? GetLeft()\r\n\tfloat? GetCenterX()\r\n\tfloat? GetRight()\r\n\tfloat? GetWidth()\r\n\t\r\n\tfloat? GetTop()\r\n\tfloat? GetCenterY()\r\n\tfloat? GetBottom()\r\n\tfloat? GetHeight()\r\n\r\n#### Set basic properties\r\n\r\n\tLeft(float left)\r\n\tCenterX(float centerX)\r\n\tRight(float right)\r\n\tWidth(float width)\r\n\r\n\tTop(float top)\r\n\tCenterY(float centerY)\r\n\tBottom(float bottom)\r\n\tHeight(float height)\r\n\r\n#### Use a RectangleF to set properties\r\n\r\n\tToLeftOf(RectangleF rect, float margin = 0)\r\n\tToRightOf(RectangleF rect, float margin = 0)\r\n\tAbove(RectangleF rect, float margin = 0)\r\n\tBelow(RectangleF rect, float margin = 0)\r\n\r\n\tAtRightOf(RectangleF rect, float margin = 0)\r\n\tAtLeftOf(RectangleF rect, float margin = 0)\r\n\tAtTopOf(RectangleF rect, float margin = 0)\r\n\tAtBottomOf(RectangleF rect, float margin = 0)\r\n\r\n\tLeftOf(RectangleF rect)\r\n\tCenterXOf(RectangleF rect)\r\n\tRightOf(RectangleF rect)\r\n\tWidthOf(RectangleF rect)\r\n\tRelativeWidthOf(RectangleF rect, float fraction)\r\n\r\n\tTopOf(RectangleF rect)\r\n\tCenterYOf(RectangleF rect)\r\n\tBottomOf(RectangleF rect)\r\n\tHeightOf(RectangleF rect)\r\n\tRelativeHeightOf(RectangleF rect, float fraction)\r\n\r\n\tLeftRightOf(RectangleF rect, float margin = 0)\r\n\tTopBottomOf(RectangleF rect, float margin = 0)\r\n\tTopLeftOf(RectangleF rect)\r\n\tCenterOf(RectangleF rect)\r\n\tSizeOf(RectangleF rect)\r\n\tRelativeSizeOf(RectangleF rect, float fraction)\r\n\r\n\tLeftTopRightBottomOf(RectangleF rect)\r\n\tLeftTopRightBottom(float left, float top, float right, float bottom)\r\n\t\r\n\tLeftTopWidthHeightOf(RectangleF rect)\r\n\tLeftTopWidthHeight(float left, float top, float width, float height)\r\n\r\n#### Use a SizeF to set properties\r\n\r\n\tSize(SizeF size)\r\n\tRelativeSize(SizeF size, float fraction)\r\n\tSize(float width, float height)\r\n\r\n#### Use a PointF to set properties\r\n\r\n\tTopLeft(PointF point)\r\n\tTopRight(PointF point)\r\n\tTopCenter(PointF point)\r\n\tCenterLeft(PointF point)\r\n\tCenterRight(PointF point)\r\n\tBottomLeft(PointF point)\r\n\tBottomCenter(PointF point)\r\n\tBottomRight(PointF point)\r\n\r\n### Reference: RectWithOriginal\r\n\t\r\n#### Transfer basic properties\r\n\r\n\tSameLeft()\r\n\tSameCenterX()\r\n\tSameRight()\r\n\tSameWidth()\r\n\r\n\tSameTop()\r\n\tSameCenterY()\r\n\tSameBottom()\r\n\tSameHeight()\r\n\r\n\tSameTopLeft()\r\n\tSameCenter()\r\n\tSameSize()\r\n\r\n#### Move / Enlarge\r\n\r\n\tLeftMovedBy(float delta)\r\n\tCenterXMovedBy(float delta)\r\n\tRightMovedBy(float delta)\r\n\r\n\tTopMovedBy(float delta)\r\n\tCenterYMovedBy(float delta)\r\n\tBottomMovedBy(float delta)\r\n\r\n\tLeftTopMovedBy(float leftDelta, float topDelta)\r\n\r\n\tWidthEnlargedBy(float delta)\r\n\tHeightEnlargedBy(float delta)\r\n\tEnlargedBy(float widthDelta, float heightDelta)\r\n\tEnlargedBy(SizeF sizeDelta)\r\n\r\n#### Multiply\r\n\r\n\tRelativeWidth(float fraction)\r\n\tRelativeHeight(float fraction)\r\n\tRelativeSize(float fraction)\r\n\t\r\n### Reference: RectangleF Extensions\r\n\r\n\tfloat CenterX()\r\n\tfloat CenterY()\r\n\r\n\tPointF TopLeft()\r\n\tPointF TopCenter()\r\n\tPointF TopRight()\r\n\tPointF CenterLeft()\r\n\tPointF Center()\r\n\tPointF CenterRight()\r\n\tPointF BottomLeft()\r\n\tPointF BottomCenter()\r\n\tPointF BottomRight()\r\n\r\n\tRectangleF MovedBy(float deltaX, float deltaY)\r\n\tRectangleF MovedRightBy(float delta)\r\n\tRectangleF MovedDownBy(float delta)\r\n\r\n\tRectWithOriginal With()\r\n\tRectWithOriginal WithSameSize()\r\n\tRectWithOriginal WithSameTopLeft()","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}